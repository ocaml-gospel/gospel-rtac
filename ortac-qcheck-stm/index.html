<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ortac-qcheck-stm.index)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – ortac-qcheck-stm</nav><header class="odoc-preamble"><h1 id="ortac/qcheck-stm"><a href="#ortac/qcheck-stm" class="anchor"></a>Ortac/QCheck-STM</h1></header><nav class="odoc-toc"><ul><li><a href="#content">Content</a></li><li><a href="#overview">Overview</a></li><li><a href="#how-to-write-gospel-specifications?">How to write Gospel specifications?</a></li><li><a href="#warning-system">Warning system</a><ul><li><a href="#ortac/qcheck-stm-specifics">Ortac/QCheck-STM specifics</a></li><li><a href="#ortac-limitations"><code>ortac</code> limitations</a></li><li><a href="#other-limitations">Other limitations</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="content"><a href="#content" class="anchor"></a>Content</h2><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>The <code>qcheck-stm</code> plugin for <code>ortac</code> (called Ortac/QCheck-STM in order to avoid ambiguities) generates a standalone executable using <a href="https://ocaml-multicore.github.io/multicoretests/">QCheck-STM</a> to perform model-based state-machine testing of a module, building up the model from its <a href="https://ocaml-gospel.github.io/gospel/">Gospel</a> specifications.</p><p>In order to be able to generate the STM module, the plugin will need five pieces of information:</p><ol><li>What type do we want to test? This is called <em>system under test</em> or <em>SUT</em> by QCheck-STM.</li><li>How to generate a value of this type? The <code>init_sut</code> function.</li><li>What is the model of this type? This is what is taken as the <em>state</em> by QCheck-STM.</li><li>How to generate the said model? The <code>init_state</code> function.</li><li>How does the model change when calling a function? The <code>next_state</code> function.</li></ol><p>Answering these five questions is done part in the command-line arguments and part in the Gospel specifications that you will have to write in a specific style.</p><p>This tutorial aims at showing how to write Gospel specifications for your modules in order to be able to automatically generate the QCheck-STM tests with the <code>ortac</code> command-line tool and its Ortac/QCheck-STM plugin.</p><p>We are going to build an example for a simple fixed-size container library.</p><h2 id="how-to-write-gospel-specifications?"><a href="#how-to-write-gospel-specifications?" class="anchor"></a>How to write Gospel specifications?</h2><p>In order to use the Ortac/QCheck-STM, the module you want to test must contain three kinds of items:</p><ol><li>The type declaration for <code>SUT</code></li><li>The function used to generate the initial value of <code>SUT</code></li><li>Functions to be tested</li></ol><p>Here is an example for the declaration of type <code>SUT</code>:</p><pre class="language-ocaml"><code>type 'a t
(*@ model size : int
    mutable model contents : 'a list *)</code></pre><p>You'll notice the Gospel specifications under the type declaration, in the special Gospel comments. These specifications give two models to the type, one non mutable and one mutable. These models are necessary (or at least some models) in order to give enough information to the <code>qcheck-stm</code> plugin to build the functional <em>state</em> that QCheck-STM will be using. This item is then bringing two needed pieces of information: what are the type of the <code>SUT</code> and the type of the <code>state</code>.</p><p>The second item is the function used for generating the inital value for <code>SUT</code>. Here again, this item will bring two needed pieces of information: how to build the initial value of <code>SUT</code> and the corresponding <code>state</code>. This is the role of the <code>make</code> function along with its specification.</p><pre class="language-ocaml"><code>val make : int -&gt; 'a -&gt; 'a t
(*@ t = make i a
    checks i &gt;= 0
    ensures t.size = i
    ensures t.contents = List.init i (fun j -&gt; a) *)</code></pre><p>Obviously, the function should return a value of type <code>SUT</code>. But more importantly, the specification has to give a value to each of the models that were given to the type <code>SUT</code> in its specification. Here, this means we need to give a value to <code>t.size</code> and to <code>t.contents</code>. The <code>checks</code> clause is part of the Gospel specification of the function, but it won't be used by the plugin to generate any code. You can give more information that the plugin needs, for example if you are also using another tool based on Gospel specifications. The plugin will simply ignore them.</p><p>Now that Ortac/QCheck-STM is able to generate an initial value for the type under test and its model, we can turn our attention to the functions we will want to test. Here is the example of the classic <code>set</code> function along with its Gospel specification written with the <code>qcheck-stm</code> ortac plugin in mind:</p><pre class="language-ocaml"><code>val set : 'a t -&gt; int -&gt; 'a -&gt; unit
(*@ set t i a
    checks 0 &lt;= i &lt; t.size
    modifies t.contents
    ensures t.contents = List.mapi (fun j x -&gt; if j = (i : integer) then a else x) (old t.contents) *)</code></pre><p>The most important purpose of the specifications (in the context of this tutorial) is to bring the last piece of information. That is to answer the question about how the model changes when calling the specified function. This is done in two steps.</p><p>First, you have to declare which of the model's field are modified in the <code>modifies</code> clause. Note that if, like in the case of the <code>set</code> function, the function is returning <code>unit</code>, it is a Gospel error to not give any <code>modifies</code> clause. But Gospel lets you write <code>modifies ()</code> in order to express the fact that the function is modifying something that is not in the model of any of the argument. However, Ortac/QCheck-STM will read the <code>modifies</code> clauses (if any) in order to determine which model's fields are modified when the function is called. The model's fields that don't appear in any of the <code>modifies</code> clauses will be considered as not modified.</p><p>Then, the plugin will look at the <code>ensures</code> clauses (the postconditions) in order to find one clause per modified field that expresses how to compute the modification. For now, the tool is not very smart. The basic rule of thumb is that you need to write down a computable description of the new model's field as a function of the old one. This will often mean that you need to write stronger postconditions that what would be necessary in another context. If the plugin can't find any suitable <code>ensures</code> clause, it will raise a warning and skip the function for test.</p><p>You can see again the <code>checks</code> clause. This time, as the function is a candidate for test, the <code>checks</code> clause will be used by the tool to check that if the condition of the clause is not respected, the function raises the <code>Invalid_arg</code> exception.</p><p>Now that the <code>set</code> function is ready to be tested, let's turn our attention to another example. Here is the example of the <code>get</code> function along with its Gospel specifications:</p><pre class="language-ocaml"><code>val get : 'a t -&gt; int -&gt; 'a
(*@ a = get t i
    checks 0 &lt;= i &lt; t.size
    ensures a = List.nth t.contents i *)</code></pre><p>Here, the <code>ensures</code> clause has another use. As the <code>get</code> function does not modifies anything, there is no need to give the values of the model’s fields after the function. Note that the <code>ensures</code> clause wouldn't have been fit for this purpose anyway. The <code>ensures</code> clauses that are not used for the <code>next_state</code> function are used for checking postconditions, here a postcondition stating a relation between the returned value and the function arguments. These <code>ensures</code> clauses are not necessary to generate the QCheck-STM tests, but they will bring strength to your tests.</p><p>In order to generate postcondition-checking, Ortac/QCheck-STM uses the <code>ensures</code> clauses that were not used for the <code>next_state</code> function but it also uses the <code>checks</code> clauses and the <code>raises</code> ones.</p><p>Now you can generate the QCheck-STM file by running the following command where you indicate the file you want to test, the function call to build a value of the type indicated in the third argument. You can write the generated code into a file, using the <code>-o</code> option.</p><pre class="language-sh"><code>$ ortac qcheck-stm example.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o stm_example.ml</code></pre><p>The generated OCaml file has a bunch of dependencies:</p><ul><li><code>qcheck-core</code></li><li><code>qcheck-core.runner</code></li><li><code>qcheck-stm.stm</code></li><li><code>qcheck-stm.sequential</code></li><li><code>qckeck-multicoretests-util</code></li><li><code>ortac-runtime</code></li></ul><p>Using the dune build system, your dune rule for the example above would look like the following:</p><pre class="language-dune"><code>(test
 (name stm_example)
 (libraries
  qcheck-core
  qcheck-core.runner
  qcheck-stm.stm
  qcheck-stm.sequential
  qcheck-multicoretests-util
  ortac-runtime
  example)
 (action
  (run %{test} --verbose)))</code></pre><h2 id="warning-system"><a href="#warning-system" class="anchor"></a>Warning system</h2><p>Now that you know what Gospel specifications for the <code>qcheck-stm</code> plugin should look like and how to generate the QCheck-STM file, let's focus on what can go wrong. The <code>qcheck-stm</code> plugin has an extensive set of warnings to help you formulate your specifications in a way it can use.</p><p>Most of the time, Ortac/QCheck-STM will skip a function if it can't generate one of the elements needed by QCheck-STM. Doing so, it will display a warning on <code>stderr</code> in order for you to be able to get an idea about test coverage.</p><h3 id="ortac/qcheck-stm-specifics"><a href="#ortac/qcheck-stm-specifics" class="anchor"></a>Ortac/QCheck-STM specifics</h3><p>Let's start with the warnings specific to the plugin.</p><p>The principle at the core of Ortac/QCheck-STM is to turn the Gospel specifications into OCaml code needed by the QCheck-STM test framework. This means that you need to provide these pieces of information into the specification in a style that allows the plugin to understand them.</p><p>The most delicate piece of information you have to give is how the function modifies the model of the <code>SUT</code>. As stated above, the plugin is looking for this information in the <code>ensures</code> clauses.</p><p>If Ortac/QCheck-STM doesn't have enough information in your specifications in order to compute the next value for every model's field appearing in a <code>modifies</code> clause, it won't be able to test the function and inform you with a warning.</p><p>For example, the following specifications are not enough for Ortac/QCheck-STM.</p><pre class="language-ocaml"><code>val ensures_not_found_for_next_state : 'a t -&gt; unit
(*@ ensures_not_found_for_next_state t
    modifies t.contents
    ensures List.length t.contents = List.length (old t.contents) *)</code></pre><p>Ortac/QCheck-STM will look at the <code>modifies</code> clause and then look for an <code>ensures</code> clause for each of the modified models that allows to compute its new value. Here, it won't find any and warn you with the following message:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_next_state.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o foo.ml
File &quot;example_next_state.mli&quot;, line 15, characters 13-23:
15 |     modifies t.contents
                  ^^^^^^^^^^
Warning: Skipping ensures_not_found_for_next_state: model contents is
         declared as modified by the function but no suitable ensures clause
         was found. Specifications should contain at least one &quot;ensures
         x.contents = ...&quot; where x is the SUT.</code></pre><p>Note that you don't have to rewrite the clause. Maybe it contains information you still want to state in your specifications. You can then add another <code>ensures</code> clause with the relevant information in order to compute the new value of the modified model. The warning message gives you the form in which the plugin expects to find the information, namely a description of the new state by an expression in which any reference to the state should be to the old state (that is the state before the function is called).</p><p>Note also that if you write <code>modifies t</code>, the plugin assumes that all the mutable fields are modified and will try to find a description for all of them. So you'll need to avoid being too general in the modifies clauses.</p><p>Internally, QCheck-STM uses an extensible type to encode function's type signature. The plugin uses the type signature to automatically generate this encoding. But, in case you are using a type that is not yet encoded in this extensible type, Ortac/QCheck-STM will generate code using the not-yet-defined constructor using the implicit rule of capitalizing the name of the type. This will generate non-compiling code, but you'll then have the chance to add the new constructor by hand in the generated code.</p><p>For example, looking at the following function along its specifications, the plugin will make the assumption that the QCheck-STM `ty` is extended with a <code>New_type</code> constructor and a <code>new_type</code> functional combinator is defined.</p><pre class="language-ocaml"><code>val type_not_supported : new_type -&gt; 'a t -&gt; new_type
(*@ y = type_not_supported x t *)</code></pre><pre class="language-sh"><code>$ ortac qcheck-stm example_unknown_type.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o foo.ml
$ grep -A 1 &quot;type cmd&quot; foo.ml
    type cmd =
      | Type_not_supported of new_type
$ grep -A 3 &quot;let run&quot; foo.ml
    let run cmd__010_ sut__011_ =
      match cmd__010_ with
      | Type_not_supported x -&gt;
          Res (new_type, (type_not_supported x sut__011_))</code></pre><p>You can open the <code>foo.ml</code> file to edit it in this way.</p><p>In Gospel, you have the possibility to use ghost values, as arguments and/or as returned values. As those values don’t exist in the actual code that will be called during the test, Ortac/QCheck-STM doesn't support Gospel specifications with ghost values in the header.</p><p>If we add the following declaration to our example file,</p><pre class="language-ocaml"><code>val ghost_arg : char -&gt; 'a t -&gt; bool
(*@ b = ghost_arg [ i : integer] c t *)</code></pre><p>the command will generate the following warning:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_ghost.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o foo.ml
File &quot;example_ghost.mli&quot;, line 14, characters 20-21:
14 | (*@ b = ghost_arg [ i : integer] c t *)
                         ^
Warning: Skipping ghost_arg: functions with a ghost argument are not
         supported.</code></pre><p>You'll need to write your specifications without using <code>ghost</code> arguments or returned value if you want to test this function with Ortac/QCheck-STM.</p><p>Finally, when you want to test a library with a parameterized type, you need to instantiate the type parameter in order to generate the QCheck-STM tests. Choosing the right instantiation implies to be careful when the library contains specialized functions.</p><p>For example, if we add the following declaration to our example file,</p><pre class="language-ocaml"><code>val incompatible_type : char -&gt; string t -&gt; bool
(*@ b = incompatible_type c t *)</code></pre><p>the plugin will generate a warning for this function and skip it.</p><pre class="language-sh"><code>$ ortac qcheck-stm example_incompatible_type.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o foo.ml
File &quot;example_incompatible_type.mli&quot;, line 13, characters 32-40:
13 | val incompatible_type : char -&gt; string t -&gt; bool
                                     ^^^^^^^^
Warning: Skipping incompatible_type: the type of its SUT-type argument is
         incompatible with the configured SUT type: char t.</code></pre><p>In the case you have functions specialized with different instantiations, you can always generate one test per possible instantiation, of course.</p><h3 id="ortac-limitations"><a href="#ortac-limitations" class="anchor"></a><code>ortac</code> limitations</h3><p>The second source of limitations is the <code>ocaml_of_gospel</code> translation provided by the <code>ortac-core</code> package. Gospel being a logical language, it is not fully executable. <code>ortac-core</code> identifies an executable subset of Gospel and translates it to OCaml. But there are still some limitations, in particular concerning quantification. For now, only well-bounded quantifications over integers are supported.</p><p>If we add the following declaration to our example file,</p><pre class="language-ocaml"><code>val unsupported_quantification : 'a t -&gt; bool
(*@ b = unsupported_quantification t
    ensures b = forall a. List.mem a t.contents -&gt; a = a *)</code></pre><p>the command will generate the following warning:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_ill_formed_quantification.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o foo.ml
File &quot;example_ill_formed_quantification.mli&quot;, line 15, characters 16-56:
15 |     ensures b = forall a. List.mem a t.contents -&gt; a = a *)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning: Skipping clause: unsupported quantification.</code></pre><p>Note that only the clause involving the unsupported quantification has not been translated. If your function's specification contains other clauses that can be translated and contain enough information for the plugin to do its job, then you will be able to test your function. If not, maybe you can rewrite the clause without involving this sort of quantification. In this particular example, you can use the <code>List.for_all</code> combinator from the Gospel standard library <code>List</code> module:</p><pre class="language-ocaml"><code>val for_all : 'a t -&gt; bool
(*@ b = for_all t
    ensures b = List.for_all (fun x -&gt; x = x) t.contents *)</code></pre><h3 id="other-limitations"><a href="#other-limitations" class="anchor"></a>Other limitations</h3><p>Finally, note that this tool is still fairly new and comes with limitations that should be lifted in the future. Fow now, we only support testing functions with exactly one <code>SUT</code> argument in its signature, we don't support tuples and we only support first-order functions.</p><p>If we add the following declarations to our example file,</p><pre class="language-ocaml"><code>val f : int -&gt; int -&gt; bool
(*@ b = f x y *)

val compare : 'a t -&gt; 'a t -&gt; bool
(*@ b = compare t1 t2 *)

val of_list : 'a list -&gt; 'a t
(*@ t = of_list xs *)

val g : int * int -&gt; 'a t -&gt; bool
(*@ b = g x t *)

val h : 'a t -&gt; 'a * 'a
(*@ (l, r) = h t *)

val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool
(*@ b = for_all p t *)</code></pre><p>Ortac/QCheck-STM will generate the following warnings:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_limitations.mli &quot;make 42 'a'&quot; &quot;char t&quot; -o foo.ml
File &quot;example_limitations.mli&quot;, line 13, characters 8-26:
13 | val f : int -&gt; int -&gt; bool
             ^^^^^^^^^^^^^^^^^^
Warning: Skipping f: functions with no SUT argument cannot be tested.
File &quot;example_limitations.mli&quot;, line 16, characters 14-34:
16 | val compare : 'a t -&gt; 'a t -&gt; bool
                   ^^^^^^^^^^^^^^^^^^^^
Warning: Skipping compare: functions with multiple SUT arguments cannot be
         tested.
File &quot;example_limitations.mli&quot;, line 19, characters 25-29:
19 | val of_list : 'a list -&gt; 'a t
                              ^^^^
Warning: Skipping of_list: functions returning a SUT value cannot be tested.
File &quot;example_limitations.mli&quot;, line 25, characters 16-23:
25 | val h : 'a t -&gt; 'a * 'a
                     ^^^^^^^
Warning: Skipping h: functions returning tuples are not supported yet.
File &quot;example_limitations.mli&quot;, line 28, characters 15-25:
28 | val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool
                    ^^^^^^^^^^
Warning: Skipping for_all: functions are not supported yet as arguments.
File &quot;example_limitations.mli&quot;, line 22, characters 8-17:
22 | val g : int * int -&gt; 'a t -&gt; bool
             ^^^^^^^^^
Warning: Type (int * int) not supported.</code></pre></div></body></html>
