type nonrec cmd =
  | Length 
  | Pop 
  | Push of char 
  | Extend 
  | To_list [@@deriving show { with_path = false }]
type nonrec state = {
  size: int ;
  contents: char list }
let next_state cmd__001_ state__002_ =
  match cmd__001_ with
  | Length -> state__002_
  | Pop ->
      {
        state__002_ with
        contents = (Ortac_runtime.Gospelstdlib.List.tl state__002_.contents)
      }
  | Push a_1 ->
      {
        state__002_ with
        contents =
          (if
             (Ortac_runtime.Gospelstdlib.List.length state__002_.contents) =
               state__002_.size
           then state__002_.contents
           else a_1 :: state__002_.contents)
      }
  | Extend ->
      {
        state__002_ with
        size =
          (Ortac_runtime.Gospelstdlib.( * )
             (Ortac_runtime.Gospelstdlib.integer_of_int 2) state__002_.size);
        contents = []
      }
  | To_list -> state__002_
let postcond cmd__003_ state__004_ res__005_ =
  let new_state__006_ = lazy (next_state cmd__003_ state__004_) in
  match (cmd__003_, res__005_) with
  | (Length, Res ((Int, _), i)) ->
      List.fold_left (&&) true
        [(Ortac_runtime.Gospelstdlib.integer_of_int i) =
           (Ortac_runtime.Gospelstdlib.List.length
              (Lazy.force new_state__006_).contents)]
  | (Pop, Res ((Char, _), a_2)) ->
      List.fold_left (&&) true
        [a_2 = (Ortac_runtime.Gospelstdlib.List.hd state__004_.contents)]
  | (Push a_1, Res ((Unit, _), _)) -> List.fold_left (&&) true []
  | (Extend, Res ((Unit, _), _)) -> List.fold_left (&&) true []
  | (To_list, Res ((List (Char), _), l)) ->
      List.fold_left (&&) true [l = (Lazy.force new_state__006_).contents]
let run cmd__007_ sut__008_ =
  match cmd__007_ with
  | Length -> Res (int, (length sut__008_))
  | Pop -> Res (char, (pop sut__008_))
  | Push a_1 -> Res (unit, (push a_1 sut__008_))
  | Extend -> Res (unit, (extend sut__008_))
  | To_list -> Res ((list char), (to_list sut__008_))
